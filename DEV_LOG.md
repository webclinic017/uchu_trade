# Dev Log

## 2024-07-27

### 系统侧
功能模块化重构：分离各个功能模块，提高代码复用性。现在代码的耦合度还是比较高，今天从数据（底座）和调度（入口）两个部分开始进行模块化重构。

对于策略实例，需要将主模型和附属模型分离；如主模型定义策略的声明周期，附属模型定义每天的生效时间（如每日开盘、每日收盘），以及每日的交易信号。

对于余额需要设置读写锁（临时想到mark一下）

后续TODO1：将完整的交易链路继续按照模块化的思路进行拆分。目前已经明确了数据模块，调度模块，但是对于数据模块自身的功能还需要进细化。

后续想法：对于调度任务，可以根据职能划分为：买入、止损、离场三个调度任务，后续可以捕捉热点的调度任务（和纯量化有点冲突，但是对于系统来说可以考虑设计）

### 量化侧
量化侧目前美国降息的可能性升高，可以入场，先搞个70%仓位，逢跌购入（限BTC、ETH和SOL），对于三天连跌+低交易量的case可以走入场，或者等右侧交易。

WLD比预期要差很多，吃了一次亏就不要再吃了，但是从盘面看WLD走出了一个higher high且在筑底的阶段，走一个右侧交易。

## 2024-07-28

下周的任务是做出交易的日志记录功能，每次自动/手动交易后记录下时间、金额、配置、仓位、交易结果等信息，方便后续分析。

## 2024-07-29

问GPT了自己的第四段代码(okx_api.py )和前三段之后(account_okx.py\post_order_contract.py\post_order_service.py)比有什么进步和体现设计模式的方面，得到了肯定的答案～还是很开心的，具体如下：

总结：
第四段代码提供了更高的封装性和统一性，适合于需要频繁调用不同API的场景，并且通过统一的接口简化了调用流程。前三段代码职责更单一，分离了账户操作和交易操作，适合于模块化的开发和管理。

第四段代码在设计上体现了几个重要的设计模式，这些模式提高了代码的可维护性、可扩展性和可读性：

单例模式（Singleton Pattern）：

在第一段和第二段代码中，每次需要访问 AccountAPI 或 TradeAPI 的实例时，都会检查实例是否已经存在，如果不存在则创建一个新的实例。这是单例模式的一种简单实现，确保每个 API 类只有一个实例。
工厂模式（Factory Pattern）：

在第四段代码中，_initialize_account_api 和 _initialize_trade_api 方法用于创建 AccountAPI 和 TradeAPI 的实例。通过这些方法，将实例化逻辑封装起来，使得创建对象的过程更加灵活。这体现了工厂模式的思想，通过工厂方法创建对象。
外观模式（Facade Pattern）：

OKXAPIWrapper 类充当了一个外观类，统一了账户和交易相关的操作接口。客户端不需要关心底层的实现细节，只需要通过 OKXAPIWrapper 类提供的方法进行调用。这大大简化了接口的使用，减少了复杂度。
策略模式（Strategy Pattern）：

第四段代码中的 env 参数用来区分模拟盘和实盘，self.flag 用来标识当前的环境。这种通过配置参数来改变行为的方式体现了策略模式的思想，使得代码可以根据不同的策略（环境）来执行不同的逻辑。
依赖注入（Dependency Injection）：

通过配置文件加载 API 密钥、密码等配置信息，并将这些配置信息注入到 AccountAPI 和 TradeAPI 的实例中。这种方式使得代码更加灵活，易于测试和维护。
装饰器模式（Decorator Pattern）：

log_method 装饰器为 get_account_balance 和 get_trade_fills_history 等方法添加了日志记录功能。这种通过装饰器为现有方法添加新功能的方式体现了装饰器模式的思想。
通过这些设计模式的运用，第四段代码在结构上更加清晰，功能上更加强大，维护起来也更加方便。

## 2024-07-30

淦，今天加班了艹，歇！